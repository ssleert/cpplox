!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/ssleert/Desktop/projects/cpplox/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	/p6.0.20221218.0/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
$(PROG)	Makefile	/^$(PROG): $(COBJS) $(CXXOBJS)$/;"	t
%.o	Makefile	/^%.o: %.c$/;"	t
%.oo	Makefile	/^%.oo: %.cc$/;"	t
AND	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
AstPrinter	ast_printer.hh	/^        class AstPrinter : public ast::Visitor<std::any> {$/;"	c	namespace:ast_printer
BANG	token.hh	/^                BANG, BANG_EQUAL,$/;"	e	enum:token::token_type
BANG_EQUAL	token.hh	/^                BANG, BANG_EQUAL,$/;"	e	enum:token::token_type
BINDIR	Makefile	/^BINDIR		?= $(PREFIX)\/bin$/;"	m
Base	examples/interface_test.cc	/^class Base {$/;"	c	file:
Base	examples/typeid_test.cc	/^class Base {$/;"	c	file:
Binary	ast.hh	/^                Binary($/;"	f	class:ast::Binary
Binary	ast.hh	/^        class Binary : public Expr {$/;"	c	namespace:ast
CC	Makefile	/^CC		= gcc$/;"	m
CLASS	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
COBJS	Makefile	/^COBJS		= ${CFILES:.c=.o}$/;"	m
COMMA	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
CXX	Makefile	/^CXX		= g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS	?= $(CFLAGS) -std=c++23$/;"	m
CXXOBJS	Makefile	/^CXXOBJS		= ${CXXFILES:.cc=.oo}$/;"	m
Child	examples/typeid_test.cc	/^class Child : public Base {$/;"	c	file:
DOT	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
Derived	examples/interface_test.cc	/^class Derived : public Base {$/;"	c	file:
ELSE	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
EQUAL	token.hh	/^                EQUAL, EQUAL_EQUAL,$/;"	e	enum:token::token_type
EQUAL_EQUAL	token.hh	/^                EQUAL, EQUAL_EQUAL,$/;"	e	enum:token::token_type
Expr	ast.hh	/^        class Expr {$/;"	c	namespace:ast
FALSE	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
FILE_EOF	token.hh	/^                FILE_EOF$/;"	e	enum:token::token_type
FOR	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
FUN	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
GREATER	token.hh	/^                GREATER, GREATER_EQUAL,$/;"	e	enum:token::token_type
GREATER_EQUAL	token.hh	/^                GREATER, GREATER_EQUAL,$/;"	e	enum:token::token_type
Grouping	ast.hh	/^                Grouping($/;"	f	class:ast::Grouping
Grouping	ast.hh	/^        class Grouping : public Expr {$/;"	c	namespace:ast
IDENTIFIER	token.hh	/^                IDENTIFIER, STRING, NUMBER,$/;"	e	enum:token::token_type
IF	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
INSTALL	Makefile	/^INSTALL		?= install -s$/;"	m
Interpreter	interpreter.hh	/^        class Interpreter : public ast::Visitor<std::any> {$/;"	c	namespace:interpreter
LEFT_BRACE	token.hh	/^                LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,$/;"	e	enum:token::token_type
LEFT_PAREN	token.hh	/^                LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,$/;"	e	enum:token::token_type
LESS	token.hh	/^                LESS, LESS_EQUAL,$/;"	e	enum:token::token_type
LESS_EQUAL	token.hh	/^                LESS, LESS_EQUAL,$/;"	e	enum:token::token_type
Literal	ast.hh	/^                Literal($/;"	f	class:ast::Literal
Literal	ast.hh	/^        class Literal : public Expr {$/;"	c	namespace:ast
Lox	cpplox.cc	/^class Lox {$/;"	c	file:
MAN	Makefile	/^MAN		= $(PROG).1$/;"	m
MANDIR	Makefile	/^MANDIR		?= $(PREFIX)\/man\/man1$/;"	m
MINUS	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
NIL	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
NUMBER	token.hh	/^                IDENTIFIER, STRING, NUMBER,$/;"	e	enum:token::token_type
OR	token.hh	/^                AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,$/;"	e	enum:token::token_type
Overload	utils.hh	/^        struct Overload : Ts ... {$/;"	s	namespace:utils
PLUS	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
PREFIX	Makefile	/^PREFIX		?= \/usr\/local$/;"	m
PRINT	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
PROG	Makefile	/^PROG		= cpplox$/;"	m
Parser	parser.hh	/^                Parser($/;"	f	class:parser::Parser
Parser	parser.hh	/^        class Parser {$/;"	c	namespace:parser
RETURN	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
RIGHT_BRACE	token.hh	/^                LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,$/;"	e	enum:token::token_type
RIGHT_PAREN	token.hh	/^                LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,$/;"	e	enum:token::token_type
SEMICOLON	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
SLASH	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
STAR	token.hh	/^                COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,$/;"	e	enum:token::token_type
STRING	token.hh	/^                IDENTIFIER, STRING, NUMBER,$/;"	e	enum:token::token_type
SUPER	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
Scanner	scanner.hh	/^                Scanner(std::wstring& source)$/;"	f	class:scanner::Scanner
Scanner	scanner.hh	/^        class Scanner {$/;"	c	namespace:scanner
SecondChild	examples/typeid_test.cc	/^class SecondChild : public Base {$/;"	c	file:
THIS	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
TRUE	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
Token	token.hh	/^                Token(token_type type,$/;"	f	class:token::Token
Token	token.hh	/^        class Token {$/;"	c	namespace:token
Unary	ast.hh	/^                Unary($/;"	f	class:ast::Unary
Unary	ast.hh	/^        class Unary : public Expr {$/;"	c	namespace:ast
VAR	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
Visitor	ast.hh	/^        class Visitor {$/;"	c	namespace:ast
WHILE	token.hh	/^                PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,$/;"	e	enum:token::token_type
__anon53fcfdd40111	utils.hh	/^        namespace {$/;"	n	namespace:utils
accept	ast.hh	/^                fn accept(Visitor<std::any>& visitor) -> std::any {$/;"	f	class:ast::Binary	typeref:typename:fn
accept	ast.hh	/^                fn accept(Visitor<std::any>& visitor) -> std::any {$/;"	f	class:ast::Grouping	typeref:typename:fn
accept	ast.hh	/^                fn accept(Visitor<std::any>& visitor) -> std::any {$/;"	f	class:ast::Literal	typeref:typename:fn
accept	ast.hh	/^                fn accept(Visitor<std::any>& visitor) -> std::any {$/;"	f	class:ast::Unary	typeref:typename:fn
add_token	scanner.hh	/^                fn add_token(token::token_type type) {$/;"	f	class:scanner::Scanner	typeref:typename:fn
add_token	scanner.hh	/^                fn add_token(token::token_type type, std::any literal) {$/;"	f	class:scanner::Scanner	typeref:typename:fn
advance	parser.hh	/^                fn advance() -> token::Token {$/;"	f	class:parser::Parser	typeref:typename:fn
advance	scanner.hh	/^                fn advance() -> wchar_t {$/;"	f	class:scanner::Scanner	typeref:typename:fn
all	Makefile	/^all: $(PROG)$/;"	t
asd	examples/shared_ptr_test.cc	/^fn asd() -> std::shared_ptr<int[]> {$/;"	f	typeref:typename:fn
ast	ast.hh	/^namespace ast {$/;"	n
ast_printer	ast_printer.hh	/^namespace ast_printer {$/;"	n
check	parser.hh	/^                fn check(token::token_type type) -> bool {$/;"	f	class:parser::Parser	typeref:typename:fn
check_number_operand	interpreter.hh	/^                fn check_number_operand(token::Token& op, std::any& operand) {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
check_number_operands	interpreter.hh	/^                fn check_number_operands(token::Token& op, std::any& left, std::any& right) {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
clean	Makefile	/^clean:$/;"	t
comment	scanner.hh	/^                fn comment() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
comment_embeds	scanner.hh	/^                size_t comment_embeds;$/;"	m	class:scanner::Scanner	typeref:typename:size_t
comparison	parser.hh	/^                fn comparison() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
consume	parser.hh	/^                fn consume(token::token_type type, std::wstring msg) -> token::Token {$/;"	f	class:parser::Parser	typeref:typename:fn
consumer	examples/interface_test.cc	/^fn consumer(Base& b) -> void {$/;"	f	typeref:typename:fn
current	parser.hh	/^                size_t current;$/;"	m	class:parser::Parser	typeref:typename:size_t
current	scanner.hh	/^                size_t current;$/;"	m	class:scanner::Scanner	typeref:typename:size_t
equality	parser.hh	/^                fn equality() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
error	errors.hh	/^        fn error(int line, std::wstring msg) {$/;"	f	namespace:errors	typeref:typename:fn
error	errors.hh	/^        fn error(token::Token t, std::wstring msg) {$/;"	f	namespace:errors	typeref:typename:fn
error	parser.hh	/^                fn error(token::Token t, std::wstring msg) -> parse_error {$/;"	f	class:parser::Parser	typeref:typename:fn
errors	errors.hh	/^namespace errors {$/;"	n
evaluate	interpreter.hh	/^                fn evaluate(std::shared_ptr<ast::Expr> expr) -> std::any {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
expr_ptr	parser.hh	/^        using expr_ptr = std::shared_ptr<ast::Expr>;$/;"	t	namespace:parser	typeref:typename:std::shared_ptr<ast::Expr>
expression	ast.hh	/^                std::shared_ptr<Expr> expression;$/;"	m	class:ast::Grouping	typeref:typename:std::shared_ptr<Expr>
expression	parser.hh	/^                fn expression() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
factor	parser.hh	/^                fn factor() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
fn	cpplox.hh	/^#define fn /;"	d
fn	examples/interface_test.cc	/^#define fn /;"	d	file:
fn	examples/shared_ptr_test.cc	/^#define fn /;"	d	file:
fn	examples/typeid_test.cc	/^#define fn /;"	d	file:
get_file	utils.hh	/^        fn get_file(std::wstring& path) -> std::wstring {$/;"	f	namespace:utils	typeref:typename:fn
get_file_lines	utils.hh	/^        fn get_file_lines(std::wstring& path) -> std::vector<std::wstring> {$/;"	f	namespace:utils	typeref:typename:fn
hadError	errors.hh	/^        bool hadError = false;$/;"	v	namespace:errors	typeref:typename:bool
had_runtime_error	errors.hh	/^        bool had_runtime_error = false;$/;"	v	namespace:errors	typeref:typename:bool
identifier	scanner.hh	/^                fn identifier() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
install	Makefile	/^install: all$/;"	t
interpret	interpreter.hh	/^                fn interpret(std::shared_ptr<ast::Expr> expr) {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
interpreter	interpreter.hh	/^namespace interpreter {$/;"	n
is_alpha_numeric	scanner.hh	/^                fn is_alpha_numeric(wchar_t c) -> bool {$/;"	f	class:scanner::Scanner	typeref:typename:fn
is_at_end	parser.hh	/^                fn is_at_end() -> bool {$/;"	f	class:parser::Parser	typeref:typename:fn
is_at_end	scanner.hh	/^                fn is_at_end() -> bool {$/;"	f	class:scanner::Scanner	typeref:typename:fn
is_equal	interpreter.hh	/^                fn is_equal(std::any& a, std::any& b) -> bool {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
is_truthy	interpreter.hh	/^                fn is_truthy(std::any& obj) -> bool {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
keywords	scanner.hh	/^                const std::unordered_map<std::wstring, token::token_type> keywords = {$/;"	m	class:scanner::Scanner	typeref:typename:const std::unordered_map<std::wstring,token::token_type>
left	ast.hh	/^                std::shared_ptr<Expr> left;$/;"	m	class:ast::Binary	typeref:typename:std::shared_ptr<Expr>
lexeme	token.hh	/^                std::wstring      lexeme;$/;"	m	class:token::Token	typeref:typename:std::wstring
line	scanner.hh	/^                size_t line;$/;"	m	class:scanner::Scanner	typeref:typename:size_t
line	token.hh	/^                int               line;$/;"	m	class:token::Token	typeref:typename:int
literal	token.hh	/^                std::any          literal;$/;"	m	class:token::Token	typeref:typename:std::any
main	cpplox.cc	/^        fn main(std::vector<std::wstring>& args) -> int {$/;"	f	class:Lox	typeref:typename:fn	file:
main	cpplox.cc	/^fn main(int argc, char* argv[]) -> int {$/;"	f	typeref:typename:fn
main	examples/interface_test.cc	/^fn main() -> int {$/;"	f	typeref:typename:fn
main	examples/shared_ptr_test.cc	/^fn main() -> int {$/;"	f	typeref:typename:fn
main	examples/typeid_test.cc	/^fn main() -> int {$/;"	f	typeref:typename:fn
match	parser.hh	/^                fn match(std::initializer_list<token::token_type> types) -> bool {$/;"	f	class:parser::Parser	typeref:typename:fn
match	scanner.hh	/^                fn match(wchar_t expected) -> bool {$/;"	f	class:scanner::Scanner	typeref:typename:fn
multiline_comment	scanner.hh	/^                fn multiline_comment() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
number	scanner.hh	/^                fn number() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
op	ast.hh	/^                token::Token op;$/;"	m	class:ast::Binary	typeref:typename:token::Token
op	ast.hh	/^                token::Token op;$/;"	m	class:ast::Unary	typeref:typename:token::Token
panic	utils.hh	/^        fn panic(std::wstring msg) {$/;"	f	namespace:utils	typeref:typename:fn
parenthesize	ast_printer.hh	/^                fn parenthesize($/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
parse	parser.hh	/^                fn parse() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
parse_error	parser.hh	/^        class parse_error : public std::exception {};$/;"	c	namespace:parser
parser	parser.hh	/^namespace parser {$/;"	n
peek	parser.hh	/^                fn peek() -> token::Token {$/;"	f	class:parser::Parser	typeref:typename:fn
peek	scanner.hh	/^                fn peek() -> wchar_t {$/;"	f	class:scanner::Scanner	typeref:typename:fn
peek_next	scanner.hh	/^                fn peek_next() -> wchar_t {$/;"	f	class:scanner::Scanner	typeref:typename:fn
previous	parser.hh	/^                fn previous() -> token::Token {$/;"	f	class:parser::Parser	typeref:typename:fn
primary	parser.hh	/^                fn primary() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
print	ast_printer.hh	/^                fn print(std::shared_ptr<ast::Expr> expr) -> std::wstring {$/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
report	errors.hh	/^        fn report(int line, std::wstring where, std::wstring msg) {$/;"	f	namespace:errors	typeref:typename:fn
right	ast.hh	/^                std::shared_ptr<Expr> right;$/;"	m	class:ast::Binary	typeref:typename:std::shared_ptr<Expr>
right	ast.hh	/^                std::shared_ptr<Expr> right;$/;"	m	class:ast::Unary	typeref:typename:std::shared_ptr<Expr>
run	cpplox.cc	/^        fn run(std::wstring& source) {$/;"	f	class:Lox	typeref:typename:fn	file:
run_file	cpplox.cc	/^        fn run_file(std::wstring& path) -> int {$/;"	f	class:Lox	typeref:typename:fn	file:
run_prompt	cpplox.cc	/^        fn run_prompt() {$/;"	f	class:Lox	typeref:typename:fn	file:
runtime_err	errors.hh	/^        fn runtime_err(runtime_panic err) {$/;"	f	namespace:errors	typeref:typename:fn
runtime_panic	errors.hh	/^                runtime_panic($/;"	f	class:errors::runtime_panic
runtime_panic	errors.hh	/^        class runtime_panic : public std::runtime_error {$/;"	c	namespace:errors
scan_token	scanner.hh	/^                fn scan_token() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
scan_tokens	scanner.hh	/^                fn scan_tokens() -> std::vector<token::Token> {$/;"	f	class:scanner::Scanner	typeref:typename:fn
scanner	scanner.hh	/^namespace scanner {$/;"	n
source	scanner.hh	/^                std::wstring source;$/;"	m	class:scanner::Scanner	typeref:typename:std::wstring
start	scanner.hh	/^                size_t start;$/;"	m	class:scanner::Scanner	typeref:typename:size_t
std	token.hh	/^namespace std { $/;"	n
string	scanner.hh	/^                fn string() {$/;"	f	class:scanner::Scanner	typeref:typename:fn
stringify	interpreter.hh	/^                fn stringify(std::any obj) -> std::wstring {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
swag	examples/interface_test.cc	/^        fn swag() -> void {$/;"	f	class:Derived	typeref:typename:fn	file:
synchronize	parser.hh	/^                fn synchronize() {$/;"	f	class:parser::Parser	typeref:typename:fn
term	parser.hh	/^                fn term() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
test	examples/typeid_test.cc	/^        fn test(T a) -> T {$/;"	f	class:Base	typeref:typename:fn	file:
test	examples/typeid_test.cc	/^        fn test(T a) -> T {$/;"	f	class:Child	typeref:typename:fn	file:
test	examples/typeid_test.cc	/^        fn test(T a) -> T {$/;"	f	class:SecondChild	typeref:typename:fn	file:
to_string	utils.hh	/^        fn to_string(std::wstring& wstr) -> std::string {$/;"	f	namespace:utils	typeref:typename:fn
to_wstring	token.hh	/^        fn to_wstring(std::wstring& s) -> std::wstring {$/;"	f	namespace:std	typeref:typename:fn
to_wstring	token.hh	/^        fn to_wstring(token::Token& t) -> std::wstring {$/;"	f	namespace:std	typeref:typename:fn
to_wstring	token.hh	/^        fn to_wstring(token::token_type& t) -> std::wstring {$/;"	f	namespace:std	typeref:typename:fn
to_wstring	utils.hh	/^        fn to_wstring(char* str) -> std::wstring {$/;"	f	namespace:utils	typeref:typename:fn
to_wstring	utils.hh	/^        fn to_wstring(std::any& value) -> std::wstring {$/;"	f	namespace:utils	typeref:typename:fn
to_wstring	utils.hh	/^        fn to_wstring(std::string& str) -> std::wstring {$/;"	f	namespace:utils	typeref:typename:fn
token	errors.hh	/^                token::Token token;$/;"	m	class:errors::runtime_panic	typeref:typename:token::Token
token	token.hh	/^namespace token {$/;"	n
token_type	token.hh	/^        enum token_type {$/;"	g	namespace:token
token_type_strs	token.hh	/^        const std::wstring token_type_strs[] = {$/;"	v	namespace:token	typeref:typename:const std::wstring[]
tokens	parser.hh	/^                std::vector<token::Token> tokens;$/;"	m	class:parser::Parser	typeref:typename:std::vector<token::Token>
tokens	scanner.hh	/^                std::vector<token::Token> tokens;$/;"	m	class:scanner::Scanner	typeref:typename:std::vector<token::Token>
type	token.hh	/^                token_type type;$/;"	m	class:token::Token	typeref:typename:token_type
u8str_conv	utils.hh	/^                std::wstring_convert<std::codecvt_utf8<wchar_t>> u8str_conv;$/;"	v	namespace:utils::__anon53fcfdd40111	typeref:typename:std::wstring_convert<std::codecvt_utf8<wchar_t>>
unary	parser.hh	/^                fn unary() -> std::shared_ptr<ast::Expr> {$/;"	f	class:parser::Parser	typeref:typename:fn
utils	utils.hh	/^namespace utils {$/;"	n
value	ast.hh	/^                std::any value;$/;"	m	class:ast::Literal	typeref:typename:std::any
visitBinaryExpr	ast_printer.hh	/^                fn visitBinaryExpr(ast::Binary& expr) -> std::any {$/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
visitBinaryExpr	interpreter.hh	/^                fn visitBinaryExpr(ast::Binary& expr) -> std::any {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
visitGroupingExpr	ast_printer.hh	/^                fn visitGroupingExpr(ast::Grouping& expr) -> std::any {$/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
visitGroupingExpr	interpreter.hh	/^                fn visitGroupingExpr(ast::Grouping& expr) -> std::any {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
visitLiteralExpr	ast_printer.hh	/^                fn visitLiteralExpr(ast::Literal& expr) -> std::any {$/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
visitLiteralExpr	interpreter.hh	/^                fn visitLiteralExpr(ast::Literal& expr) -> std::any {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
visitUnaryExpr	ast_printer.hh	/^                fn visitUnaryExpr(ast::Unary& expr) -> std::any {$/;"	f	class:ast_printer::AstPrinter	typeref:typename:fn
visitUnaryExpr	interpreter.hh	/^                fn visitUnaryExpr(ast::Unary& expr) -> std::any {$/;"	f	class:interpreter::Interpreter	typeref:typename:fn
~Base	examples/typeid_test.cc	/^        virtual ~Base() {};$/;"	f	class:Base	file:
